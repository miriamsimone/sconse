rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    // Conversation media uploads
    // Path: conversations/{conversationId}/media/{allPaths=**}
    match /conversations/{conversationId}/media/{allPaths=**} {
      // TEMPORARY DEV MODE: Allow ALL access for debugging
      // TODO: Remove this and add proper security before production!
      allow read, write: if true;
      
      // Helper function to check if user is a participant in the conversation
      function isParticipant() {
        // Allow DM conversations based on ID pattern (matches Firestore rules)
        let isDMParticipant = conversationId.matches('dm_.*' + request.auth.uid + '.*');
        
        // Or check if user is in participants array for group conversations
        let isInParticipants = firestore.exists(/databases/(default)/documents/conversations/$(conversationId)) &&
                               request.auth.uid in firestore.get(/databases/(default)/documents/conversations/$(conversationId)).data.participants;
        
        return request.auth != null && (isDMParticipant || isInParticipants);
      }
      
      // Helper function to validate file upload
      function isValidUpload() {
        return request.resource.size < 10 * 1024 * 1024 && // Max 10MB
               request.resource.contentType.matches('image/.*|video/.*|audio/.*'); // Only media files
      }
      
      // Allow write if user is authenticated, is a participant, and file is valid
      allow write: if request.auth != null && isParticipant() && isValidUpload();
      
      // Allow delete only by the uploader
      allow delete: if request.auth != null && 
                       resource.metadata != null &&
                       resource.metadata.uploaderId == request.auth.uid;
    }
    
    // User profile pictures
    // Path: users/{userId}/profile/{allPaths=**}
    match /users/{userId}/profile/{allPaths=**} {
      // Helper function to validate profile picture
      function isValidProfilePicture() {
        return request.resource.size < 5 * 1024 * 1024 && // Max 5MB
               request.resource.contentType.matches('image/.*'); // Only images
      }
      
      // Allow read by any authenticated user
      allow read: if request.auth != null;
      
      // Allow write only by the user themselves
      allow write: if request.auth != null && 
                      request.auth.uid == userId && 
                      isValidProfilePicture();
      
      // Allow delete only by the user themselves
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    // Group conversation avatars
    // Path: conversations/{conversationId}/avatar/{allPaths=**}
    match /conversations/{conversationId}/avatar/{allPaths=**} {
      // Helper function to check if user is a participant
      function isParticipant() {
        // Allow DM conversations based on ID pattern (matches Firestore rules)
        let isDMParticipant = conversationId.matches('dm_.*' + request.auth.uid + '.*');
        
        // Or check if user is in participants array for group conversations
        let isInParticipants = firestore.exists(/databases/(default)/documents/conversations/$(conversationId)) &&
                               request.auth.uid in firestore.get(/databases/(default)/documents/conversations/$(conversationId)).data.participants;
        
        return request.auth != null && (isDMParticipant || isInParticipants);
      }
      
      // Helper function to validate avatar
      function isValidAvatar() {
        return request.resource.size < 2 * 1024 * 1024 && // Max 2MB
               request.resource.contentType.matches('image/.*'); // Only images
      }
      
      // Allow read by participants
      allow read: if isParticipant();
      
      // Allow write by participants
      allow write: if request.auth != null && isParticipant() && isValidAvatar();
      
      // Allow delete by participants
      allow delete: if request.auth != null && isParticipant();
    }
    
    // Deny all other access
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}

